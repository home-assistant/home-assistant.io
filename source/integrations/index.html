---
title: "Integrations"
description: "List of the built-in integrations of Home Assistant."
sidebar: false
is_homepage: true
feedback: false
body_id: components-page
regenerate: false
---

{%- comment -%}Can't use where to count nil because of https://github.com/jekyll/jekyll/issues/6038{%- endcomment -%}
{%- assign tot = 0 -%}
{%- for comp in site.integrations -%}
{%- if comp.ha_category -%}
{%- if comp.ha_category.first -%}
{%- assign tot = tot | plus: comp.ha_category.size -%}
{%- else -%}
{%- assign tot = tot | plus: 1 -%}
{%- endif -%}
{%- endif %}
{%- endfor -%}

{%- assign components = site.integrations | sort: 'title' -%}
{%- assign components_by_version = site.integrations | group_components_by_release -%}
{%- assign categories = components | map: 'ha_category' | join: ',' | downcase | split: ',' | uniq | sort -%}
{%- assign iot_classes = components | map: 'ha_iot_class' | join: ',' | join: ',' | split: ',' | uniq | sort -%}
{%- assign quality_scales = components | map: 'ha_quality_scale' | join: ',' | join: ',' | split: ',' | uniq | sort  -%}

<div class="grid">
  <div class="grid-filters">
    <div class="grid__item one-quarter lap-one-whole palm-one-whole">
        <div class="integration_filter">
          <h3 class="filter-title">Category</h3>
          <select class="ha_category" name="category" data-id="cat">
            <option value="#">All</option>
            <option value="featured">Featured</option>
            <option value="wwha">Partner brands</option>

            <!-- {%- for category in categories -%} -->
            <!-- {%- assign components_count = components | where: 'ha_category', category | size -%} -->
            <!-- {%- if category and category != 'Other' and components_count != 0 -%} -->
            <!-- <option value='{{ category | slugify }}'>{{ category }}</option> -->
            <!-- {%- endif -%} -->
            <!-- {%- endfor -%} -->

             {%- for category in categories -%}
          {%- assign category_name = "" -%}
          {%- assign components_count = 0 -%}
          {%- for comp in components -%}
            {%- assign comp_categories = comp.ha_category | join: ',' | downcase -%}
            {%- if comp_categories contains category -%}
              {%- if category_name == "" -%}
                {%- for cat in comp.ha_category -%}
                  {%- assign lower_cat = cat | downcase -%}
                  {%- if lower_cat == category -%}
                    {%- assign category_name = cat -%}
                  {%- endif -%}
                {%- endfor -%}
              {%- endif -%}
              {%- assign components_count = components_count | plus: 1 -%}
            {%- endif -%}
          {%- endfor -%}
          {%- if category != 'other' and components_count != 0 -%}
            {%- if category_name == "" -%}
              {%- assign category_name = category | capitalize -%}
            {%- endif -%}
            <option value='{{ category | slugify }}'>{{ category_name }}</option>
          {%- endif -%}
        {%- endfor -%}

            <option value='other'>Other</option>

          </select>
        </div>
    </div>

    <div class="grid__item one-quarter lap-one-whole palm-one-whole">
      <div class="integration_filter">
        <h3 class="filter-title">Version</h3>
        <select class="ha_category" name="versions" data-id="version">
          <option value="#">All</option>
          {%- for group in components_by_version -%}
          <optgroup label="{{ group.label }} ({{group.new_components_count}})">
            {%- for version in group.versions -%}
            <option value="{{ version.label }}">{{ version.label }}</option>
            {%- endfor -%}
          </optgroup>
          {%- endfor -%}
        </select>
      </div>
    </div>

    <div class="grid__item one-quarter lap-one-whole palm-one-whole">
      <div class="integration_filter">
        <h3 class="filter-title">IoT Class</h3>
        <select class="ha_category" name="iot_classes" data-id="iot_class">
          <option value="#">All</option>
          {%- for iot_class in iot_classes -%}
            {%- assign iot_class_count = components | where: 'ha_iot_class', iot_class | size -%}
            {%- if iot_class_count != 0 -%}
            <option value="{{ iot_class | slugify }}">{{ iot_class }}</option>
            {%- endif -%}
          {%- endfor -%}
        </select>
      </div>
    </div>

    <div class="grid__item one-quarter lap-one-whole palm-one-whole">
      <div class="integration_filter">
        <h3 class="filter-title">Quality Scale</h3>
        <select class="ha_category" name="quality_scales" data-id="quality_scale">
          <option value="#">All</option>
          {%- for quality_scale in quality_scales -%}
            {%- assign quality_scale_count = components | where: 'ha_quality_scale', quality_scale | size -%}
            {%- if quality_scale_count != 0 -%}
            <option value="{{ quality_scale | slugify }}">{{ quality_scale | capitalize }}</option>
            {%- endif -%}
          {%- endfor -%}
        </select>
      </div>
    </div>
  </div>

  <div class="grid__item six-sixths lap-one-whole palm-one-whole">
    <div class="component-search">
      <form onsubmit="event.preventDefault(); return false">
        <input type="text" name="search" id="search" data-id="search" class="search" placeholder="Search integrations..." autofocus />
      </form>
    </div>
  </div>


  <div class="grid__item six-sixths lap-one-whole palm-one-whole">
    <div class="hass-option-cards" id="componentContainer"> </div>
  </div>
</div>

<script type="text/javascript">
// This object contains all components we have
const integrations = [
  {%- for component in components -%}
    {%- if component.ha_category -%}
      {%- assign sliced_version = component.ha_release | split: '.' -%}
      {%- assign minor_version = sliced_version[1]|plus: 0 -%}
      {%- assign major_version = sliced_version[0]|plus: 0 -%}
      {% assign categories = "" | split: ',' %}
      {%- for ha_category in component.ha_category -%}
        {% capture category %}"{{ ha_category | slugify | downcase }}"{% endcapture %}
        {% assign categories = categories | push: category %}
      {%- endfor -%}
      {
        url:"{{ component.url }}",
        title:"{{component.title}}",
        cat: [{{categories|join: ","}}],
        featured: {{ component.featured }},
        version: "{{major_version}}.{{minor_version}}",
        logo: "{{component.logo}}",
        domain: "{{component.ha_domain}}",
        ha_brand: "{{component.ha_brand}}",
        wwha: {% if component.works_with %}true{% else %}false{% endif %},
        iot_class: "{{component.ha_iot_class | slugify }}",
        quality_scale: "{{component.ha_quality_scale}}"
      },
    {% endif -%}
  {%- endfor -%}
  false
];
integrations.pop(); // remove placeholder element at the end
</script>

<script type="text/javascript">
  (function () {
    let filteredComponents = {};
    const baseHashRegex = /(^.*)(?=\?)/;
    const $integrationFilters = [...document.querySelectorAll('.integration_filter select')];

    const searchInputEl = document.querySelector('.component-search input');
    const componentContainerEl = document.querySelector('#componentContainer');

    function init() {
      let queryParams = new URLSearchParams(document.location.search);
      // do the lowerCase transformation once
      for (i = 0; i < integrations.length; i++) {
        title = integrations[i].title.toLowerCase();
        domain = integrations[i].domain;
        iot_class = integrations[i].iot_class;
        quality_scale = integrations[i].quality_scale;
        title_normalized = title.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        title_dedashed = title.replace(/[-_]/g, " ");
        title_normalized_dedashed = title_normalized.replace(/[-_]/g, " ");

        integrations[i].titleLC = title;
        integrations[i].search = `${title} ${title_normalized} ${title_dedashed} ${title_normalized_dedashed} ${domain} ${iot_class} ${quality_scale}`;
      }

      // sort the components alphabetically
      integrations.sort(function (a, b) {
        return a.titleLC.localeCompare(b.titleLC);
      });

      //add these to the window for dynamic grabbing in matchSelectToURL()
      window.$catFilter = document.querySelector('.integration_filter select[data-id="cat"]');
      window.$versionFilter = document.querySelector('.integration_filter select[data-id="version"]');
      window.$iot_classFilter = document.querySelector('.integration_filter select[data-id="iot_class"]');
      window.$quality_scaleFilter = document.querySelector('.integration_filter select[data-id="quality_scale"]');
      window.$searchFilter = document.querySelector('.component-search input');

      //listen for changes in the hash / user clicking back or forward button in browser
      window.addEventListener('hashchange', applyFilter);
      window.addEventListener('popstate', applyFilter);

      //on initial page load, if there's no active filters set the default to featured
      let query = buildQueryFromURL();
      if (Object.keys(query).length === 0) {
        updateQueryURL('cat', 'featured');
      }
      applyFilter();

      // add focus to the search field
      setTimeout(() => searchInputEl.focus(), 1);
    }
    init();

    // get query value pair that matches provided id from url. // for buildQueryFromURL()
    function getQueryValue(id) {
      let index = id.length + 2; // id + '#' and '/' => '#search/'
      if (id === 'cat') {
        index = 1;
      }

      // get value from #hash url
      let query = decodeURIComponent(location.hash).substring(index).toLowerCase();

      // get value from ?query url if it's present
      let queryParams = new URLSearchParams(location.search);
      if (queryParams.has(id)) {
        query = queryParams.get(id);
      }

      return query;
    }

    // build out query object of active filters for applyFilter()
    function buildQueryFromURL() {
      let queryFilter = {};
      let hash = location.hash || '';
      let queryParams = new URLSearchParams(location.search);

      if (hash.startsWith('#all') || queryParams.get('cat') === 'all') {
        queryFilter.cat = 'all';
      }

      if (hash.startsWith('#featured') || queryParams.get('cat') === 'featured') {
        // only show those with featured = true
        queryFilter.cat = 'featured';
      }

       if (hash.startsWith('#works-with-home-assistant') || queryParams.get('cat') === 'wwha') {
        // only show those with featured = true
        queryFilter.cat = 'wwha';
      }

      if (hash.startsWith('#search/') || queryParams.has('search')) {
        let query = getQueryValue('search');
        queryFilter.search = query;
      } else {
        // reset search box when not searching
        $searchFilter.value = '';
      }

      if (hash.startsWith('#version/') || queryParams.has('version')) {
        // filter by a version
        let query = getQueryValue('version');
        queryFilter.version = query;
      }

      if (
          // check for categories that are not featured or all
          (hash.startsWith('#') || queryParams.has("cat"))
          && !(hash.startsWith('#all') || queryParams.get("cat") === 'all')
          && !(hash.startsWith('#featured') || queryParams.get("cat") === 'featured')
          && !(hash.startsWith('#works-with-home-assistant') || queryParams.get("cat") === 'wwha')
          && !(hash.startsWith('#search'))
          && !(hash.startsWith('#version'))
          && !(hash.startsWith('#iot_class'))
          && !(hash.startsWith('#quality_scale'))
        ) {
        // regular filter categories
        let query = getQueryValue('cat');
        queryFilter.cat = query;
      }

      if (hash.startsWith('#iot_class/') || queryParams.has('iot_class')) {
        let query = getQueryValue('iot_class');
        queryFilter.iot_class = query;
      }

      if (hash.startsWith('#quality_scale/') || queryParams.has('quality_scale')) {
        let query = getQueryValue('quality_scale');
        queryFilter.quality_scale = query;
      }

      // filter all components by comparing against query object
      return queryFilter;
    }

    // filter all components, based on the locations hash/search and render them into the component box
    function applyFilter() {
      var data = {
        components: []
      };

      // fade-out css effect on the old elements. This is actually not visible on fast browsers
      componentContainerEl.classList.add('remove-items');

      let query = buildQueryFromURL();

      // update dom elements to match new filters
      updateFilterButtons(query);
      updateFilterElements(query);

      data.components = integrations.filter(function(integration) {
        for (let key in query) {
          // add 'featured' into integration category array // enables filtration by featured
          // also allows search of 'featured' since this is added before search is checked
          if (query[key] === 'featured') {
            if (integration.featured) {
              integration['cat'].push('featured')
            }
          }

          if (query[key] === 'works with home assistant' || 'wwha') {
            if (integration.wwha) {
              integration['cat'].push('wwha')
            }
          }

          // compare against search string and categories in integration
          if (key === 'search') {
            if (
              integration[key].indexOf(query[key]) === -1
              && integration.cat.find((c) => c.includes(query[key])) == undefined
            ) {
              return false;
            }
          }

          // add 'all' into integration category array // enables filtration by all
          integration['cat'].push('all');

          // check for matching categories in integation's category array
          if (key === 'cat') {
            if (!integration[key].includes(query[key])) return false;
          }

          // check for version / iot / quality matches
          if (!(key === 'cat' || key === 'search')) {
            if (
              integration[key] == undefined // match doesn't exist
              || integration[key] != query[key] // strings dont match
            ) {
              return false;
            }
          }
        }

        return true;
      });

      // let rendered = Mustache.render(template, data);
      let rendered;
      if (data.components.length > 0) {
        // Note: Assumes all data has already been sanitized
        rendered = data.components.map(component => `
          <a href="${component.url}" class="option-card">
            <div class="img-container">${buildImageEl(component)}</div>
            <div class='title'>${component.title}</div>
          </a>
          `).join('\n');
      } else {
        rendered = '<div class="alert alert-note"><p class="alert-content">Nothing found!</p></div>';
      }

      // remove previous elements and css classes, add the new stuff and then trigger the fade-in css animation
      componentContainerEl.innerHTML = '';
      componentContainerEl.classList.remove('show-items');
      componentContainerEl.classList.remove('remove-items');
      componentContainerEl.innerHTML = rendered;
      componentContainerEl.classList.add('show-items');
    }

    // update the browser location search. This enables users to use the browser-history
    // used for adding / updating a filter in the url
    function updateQueryURL(id, value) {
      const hashExists = location.hash !== '';
      let queryParams = new URLSearchParams(location.search);
      let query = buildQueryFromURL();

        // append url to query
        if (hashExists) {
          location.hash = '';
          let currentId = Object.keys(query)[0];
          let currentVal = Object.values(query)[0];
          queryParams.set(currentId, currentVal);
        }

        queryParams.set(id, value);
        newURL = `?${queryParams.toString()}`;

      if ('pushState' in history) {
            history.pushState('', '', newURL);
        } else {
            location.search = newURL;
      }

      //make sure search input keeps text after url is adjusted
      if (queryParams.has('search')) {
        let searchText = queryParams.get('search');
        $searchFilter.value = searchText;
      }
    }

    //remove a filter in the url
    function removeQueryFromURL(queryId) {
      const hashExists = location.hash !== '';
      let newURL;
      const baseHashRegex = /(^.*)(?=\?)/;
      const queryParams = new URLSearchParams(location.search);

      if (hashExists) {
        location.hash = '';
      } else {
        queryParams.delete(queryId);
        if (queryParams.toString() !== '') {
          let baseURL = location.href.match(baseHashRegex)[0];
          newURL = `${baseURL}?${queryParams.toString()}`
        } else {
          newURL = location.href.match(baseHashRegex)[0];
        }
      }

      if ('pushState' in history) {
        history.pushState('', '', newURL);
      } else {
        location.href = newURL;
      }
    }

    //update a specific filter dropdown / search. used in updateFilterElements()
    function matchFilterToURL(id, query) {
      //dynamically grab select variables
      let $filterElement = window[`$${id}Filter`];
      let options = [...$filterElement.querySelectorAll('option')]

      //set the value of select dropdown if it doesn't currently match the query in the url
      if ($filterElement.value !== query) {
        // set value of search input
        if (id === 'search') {
          $filterElement.value = query;
        }

        // only change the select dropdown if it matches an available dropdown value
        options.forEach(option => {
          if (option.value === query) {
            $filterElement.value = query;
          }
        })
      }
    }

    // update all filter elements to match current filter obj
    function updateFilterElements(queryFilter) {
      let filterElements = [...document.querySelectorAll('.integration_filter select, input.search')];
      let activeFilterElements = filterElements.filter(el => !(el.value === '#' || el.value === ''));

      // clear filters if there's more than the current queryFilter
      if (activeFilterElements.length > Object.keys(queryFilter).length) {
        // filter out filter elements that don't match query object
        let filtersToClear = activeFilterElements.filter(el => {
          for (key in queryFilter) {
             if (el.getAttribute('data-id') === key) return false;
          }
          return true;
        });

        // reset filter elements to default empty value
        filtersToClear.forEach(filter => {
          let queryId = filter.getAttribute('data-id');
          if (queryId !== 'search') {
            matchFilterToURL(queryId, '#');
          } else {
            matchFilterToURL(queryId, '');
          }
        });
      } else {
         // update new filters
         if (Object.keys(queryFilter).length) {
          for (key in queryFilter) {
            matchFilterToURL(key, queryFilter[key]);
          }
        }
      }
    }

    // filter button name cleanup. used in updateFilterButtons()
    function getButtonText(id, key) {
      let category;
      switch(id) {
        case 'cat':
          category = 'Category';
          break;
        case 'iot_class':
          category = 'IoT class';
          break;
        case 'quality_scale':
          category = 'Quality scale';
          break;
        default:
          category = id;
      }

      if (id !== 'search') {
        let $filterElement = window[`$${id}Filter`];
        let options = [...$filterElement.querySelectorAll('option')]
        let filteredOption = options.filter(option => option.value === key)[0];
        return `${category}: ${filteredOption.innerText}`;
      } else {
        return `${category}: ${key}`;
      }
    }

    // update all filter buttons to match current obj filter
    function updateFilterButtons(queryFilter) {
      let filterButtonParent = document.querySelector('.component-search');
      let currentFilterButtons = [...document.querySelectorAll('.component-search .active-filter')];

      // remove buttons if there's more than the current queryFilter
      if (currentFilterButtons.length > Object.keys(queryFilter).length) {
        // filter out buttons that dont match query obj
        let buttonsToRemove = currentFilterButtons.filter(button => {
          for (key in queryFilter) {
             if (button.dataset.id === key) {
               return false;
             }
          }
          return true;
        });
        buttonsToRemove.forEach(button => button.remove());
      } else if (currentFilterButtons.length === Object.keys(queryFilter).length) {
        // update text of buttons if changed
        currentFilterButtons.forEach(button => {
          for (key in queryFilter) {
             if (button.dataset.id === key) {
              // check for mismatched filter value
               if (button.dataset.filter !== queryFilter[key]) {
                 button.dataset.filter = queryFilter[key];
                 button.innerHTML = `<span>${getButtonText(key, queryFilter[key])} <iconify-icon icon="mdi:close-circle"></iconify-icon></span>`;
               }
             }
          }
        });
      } else {
        //create a filter button if one doesn't already exists
        for (key in queryFilter) {
          if (document.querySelector(`.component-search .active-filter[data-id="${key}"]`) === null) {
            let button = document.createElement('button');
            button.innerHTML = `<span>${getButtonText(key, queryFilter[key])} <iconify-icon icon="mdi:close-circle"></iconify-icon></span>`;
            button.classList.add('active-filter');
            button.dataset.id = key;
            button.dataset.filter = queryFilter[key]
            //add click listener to button to remove filter
            button.addEventListener('click', function() {
              removeQueryFromURL(this.dataset.id);
              applyFilter();
              // remove event listener after click
            }, {once:true});

            //add button to the dom
            filterButtonParent.appendChild(button);
          }
        }
      }
    }

    function buildImageEl(component) {
      const urlBase = [
        'https://brands.home-assistant.io',
        component.ha_brand ? 'brands' : '_',
        component.domain,
        'icon'
      ].join('/');

      return `<img src="${urlBase}.png" srcset="${urlBase}@2x.png 2x" loading="lazy">`;
    }

    // update view on select change
    $integrationFilters.forEach(select => select.addEventListener("change", () => {
      let id = select.dataset.id;
      let value = select.value;

      if (value !== '#') {

        updateQueryURL(id, value);
        applyFilter();
      } else {
        // clear current filter
        removeQueryFromURL(id);
        applyFilter();
      }

      return false;
    }));

    /**
     * Simple debounce implementation
     */
    function debounce(func, wait) {
      let timeout;
      return () => {
        clearTimeout(timeout);
        timeout = setTimeout(func, wait);
      };
    };

    // update view by search text
    searchInputEl.addEventListener('keyup', debounce(() => {
      let value = searchInputEl.value;
      // sanitize input
      value = value.replace(/[(\?|\&\{\}\(\))]/gi, '').trim();
      if (typeof value === "string" && value.length >= 1) {
        updateQueryURL('search', value);
        applyFilter();
      }
      else {
        removeQueryFromURL('search');
        applyFilter();
      }
    }, 500));
  })();
</script>

<noscript>
  <ul>
    {%- for component in components -%}
    {%- if component.ha_category -%}
    <li><a href='{{ component.url }}'>{{ component.title }}</a></li>
    {%- endif -%}
    {%- endfor -%}
  </ul>
</noscript>
