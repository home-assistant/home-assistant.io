<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: How-To | Home Assistant]]></title>
  <link href="https://home-assistant.io/blog/categories/how-to/atom.xml" rel="self"/>
  <link href="https://home-assistant.io/"/>
  <updated>2017-11-05T14:11:39+00:00</updated>
  <id>https://home-assistant.io/</id>
  <author>
    <name><![CDATA[Home Assistant]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Home Assistant and SSH]]></title>
    <link href="https://home-assistant.io/blog/2017/11/02/secure-shell-tunnel/"/>
    <updated>2017-11-02T08:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2017/11/02/secure-shell-tunnel</id>
    <content type="html"><![CDATA[Most system engineers are very familiar with [SSH (Secure shell)](https://en.wikipedia.org/wiki/Secure_Shell). This tool which contains a server part and a client part is used to access a remote system in a secure way. It can also help you if your are running Home Assistant but don't want to expose it to the public. On a Linux system SSH is often available by default. If you are using a Windows installation additional steps are required which are not covered here.

In this blog post we are going to use the tunneling option of SSH to create a secure connection and forward the Home Assistant frontend to a local system. 

<!--more-->

The involved parties are:

- **Remote system**: Where Home Assistant is running, usually in your home network.
- **Local system**: Where you want to see the frontend.

The prerequirements are that you need to allow the forwarding of port 22 from your router to the system where Home Assistant is running in your network. It might also be needed that you enable the SSH daemon by `$ sudo systemctl start sshd` on the remote system and to adjust the host firewall. If you are running [Hass.io](https://home-assistant.io/hassio/) then enable the [SSH Server add-on](https://home-assistant.io/addons/ssh/). You must also have a public IP address or hostname which can be provided by dynamic DNS (e.g., [NO-IP](https://www.noip.com/) or [DuckDNS](https://www.duckdns.org/)).
On your local system you need only a SSH client and you need to be in a network where SSH is allowed.

First let's have a look at the command we are going to use. Use `man ssh` to get more information.

```bash
$ ssh -L 8000:localhost:8123 user@[IP_ADDRESS_REMOTE]
      |  |    |         |    |    |
      |  |    |         |    |    |_ IP address or hostname of your router.
      |  |    |         |    |_ Username on the remote system.
      |  |    |         |_ Port where the application is running.
      |  |    |_ We want the frontend on this system.
      |  |_ The port on our local system to use (above 1024).
      |_ We want to do local port forwarding.
```

A possible example could look like the command below. 

```bash
$ ssh -L 8000:localhost:8123 ha@192.168.0.11
```

The first time you establish the connection you need to accept the fingerprint.

```bash
The authenticity of host '192.168.0.11 (192.168.0.11)' can't be established.
ECDSA key fingerprint is SHA256:asdf2faasd4gk45454fadr78wfadfasdfeg4vvvsae33.
ECDSA key fingerprint is MD5:44:d4:f7:44:d4:aa:b8:de:ef:09:3e:0d:4e:12:11:09.
Are you sure you want to continue connecting (yes/no)? 
Warning: Permanently added '192.168.0.162' (ECDSA) to the list of known hosts.
ha@192.168.0.11's password: 
Last login: Fri Oct 27 17:50:09 2017
[ha@home-assistant ~]$ 
```

Now you are able to use your frontend on your local system: [http://localhost:8000](http://localhost:8000)

Things to keep in mind:

- You need a public IP address or hostname (Dynamic DNS will work) if you want to use it from the internet.
- You need to setup port forwarding on your router.
- Don't allow `root` to use SSH. Set `PermitRootLogin no` on the remote system.
- Your local port must be above 1024. Only `root` is allowed to forward privileged ports which are below 1024.
- Use [SSH keys for authentication](https://docs-old.fedoraproject.org/en-US/Fedora/14/html/Deployment_Guide/s2-ssh-configuration-keypairs.html) instead of passwords to avoid bruteforce attacks.

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Home Assistant Demo]]></title>
    <link href="https://home-assistant.io/blog/2017/10/28/demo/"/>
    <updated>2017-10-28T08:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2017/10/28/demo</id>
    <content type="html"><![CDATA[If you are planning to host a Home Assistant meetup or doing a talk, then you probably want to show Home Assistant to an audience. You could use a Wireless router, bulbs, switches, and a single board computer to do a realistic demo. For a workshop, this is what I usually do because I think that working with physical hardware is more fun for the participants. The issue is that you need time to set up, power and space. For a talk or in a location, where you only have a beamer and a table or a lectern, the physical hardware approach is not very convenient.

The simplest way to show Home Assistant to others is the online demo at [https://home-assistant.io/demo/](https://home-assistant.io/demo/)

<p class='img'>
  <img src='/images/blog/2017-10-interactive-demo/online-demo.png' />
  Home Assistant's online demo
</p>

<!--more-->

## <a class='title-link' name='--demo-mode-and-demo-platform' href='#--demo-mode-and-demo-platform'></a> `--demo-mode` and Demo platform 
To be safe for your talk, you don't want to depend on an internet connection. The demo mode [`--demo-mode`](/docs/tools/hass/) allows you to run a demo locally including the latest features. Make sure that you have a backup of your configuration.

```bash
$ hass --demo-mode
```

If you already have a `configuration.yaml` file in place then you will get a combination of your setup with all available  [`demo`](/components/demo/) platforms. This can be overwhelming for the audience. The suggestion is that you tailor the demo to your needs by only showing a few selected platforms. For example:

```yaml
sensor:
  - platform: demo
binary_sensor:
  - platform: demo
switch:
  - platform: demo
```

<p class='img'>
  <img src='/images/blog/2017-10-interactive-demo/demo-platforms.png' />
  Home Assistant's demo platforms
</p>

## <a class='title-link' name='random-platforms' href='#random-platforms'></a> `random` platforms 
Till now the frontend is static. Nothing is changing over time. Starting with 0.57 we ship a [`random` binary sensor](https://github.com/home-assistant/home-assistant.github.io/blob/next/source/_components/binary_sensor.random.markdown) platform in addition to the already available [`random` sensor](/components/sensor.random/).

By adding those platform to your `configuration.yaml` file, your demo will become more interactive.

```yaml
sensor:
  - platform: demo
    name: Temperature
    unit_of_measurement: "°C"
binary_sensor:
  - platform: random
    name: Front Door
  - platform: random
    name: Back Door
    scan_interval: 5
```

<p class='img'>
  <img src='/images/blog/2017-10-interactive-demo/demo-random.png' />
  Demo with `random` platforms
</p>

The `random` and the `demo` platforms can, of course, be used together. With a little work and some of the [`template`](/components/#search/template) platforms or the [`input_*`](/components/#search/input) components it would even be possible to simulate a complete apartment or a house. For a hint check the sample below:


```yaml
input_boolean:
  on_off:
    name: On or off
binary_sensor:
  - platform: template
    sensors:
      on_tester:
        value_template: "{{ states.input_boolean.on_off.state == 'on' }}"
        friendly_name: 'Movement'
        device_class: motion
```


## <a class='title-link' name='mqtt-discovery' href='#mqtt-discovery'></a> MQTT Discovery 
This is a section for advanced users as it will require to run a separate script. Instead of adding `demo` platforms to the configuration this setup make use of [MQTT discovery](/docs/mqtt/discovery/) and the [embedded MQTT broker](/docs/mqtt/broker/#embedded-broker). Simply add MQTT to your `configuration.yaml` file with `discovery:`

```yaml
mqtt:
  discovery: true
```

Download the [sample script](https://github.com/home-assistant/home-assistant-dev-helper/blob/master/ha-mqtt-demo.py). It depends on [paho-mqtt](https://pypi.python.org/pypi/paho-mqtt). If you run the script inside your [Home Assistant's virtual environment](/docs/installation/virtualenv/) then you are good to go as the dependency should be present if you have used MQTT before. Otherwise, install it with `$ pip3 install paho-mqtt`. The same applies to the embedded broker.

```bash
(ha)[ha-demo]$ python3 ha-mqtt-demo.py
Demo is running... -> CTRL + C to shutdown
```

It will create sensors, a light, and a switch and update the states as long the script is running. It possible to stop and restart script without losing the entities.

Some users share their slides and other documents in [our assets repository](https://github.com/home-assistant/home-assistant-assets). Also, take a look at that repository if you need a logo for your slides.

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serial analog sensor]]></title>
    <link href="https://home-assistant.io/blog/2017/10/23/simple-analog-sensor/"/>
    <updated>2017-10-23T06:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2017/10/23/simple-analog-sensor</id>
    <content type="html"><![CDATA[This blog post is about building a super simple analog sensor for Home Assistant. The physical sensor will send the data over its virtual serial port as it will be connected over USB. The concept is similar to the [TEMPer USB](/components/sensor.temper/) devices. The attatched sensor type to the microcontroller can be any kind of sensor which gives you an analog signal from brightness over soil moisture to temperature.

The microcontroller will only transfer the voltage of an analog input pin which will be between 0 and 1024. Home Assistant will use the new [`serial`](/components/sensor.serial/) sensor platform to read the data and perform actions to convert the raw reading into a real measurement. This means that you don't have to adjust the code of your microcontroller if you change the attached sensor type.

<p class='img'>
  <img src='/images/blog/2017-10-analog-sensor/analog-sensor.png' />
  The assembled sensor
</p>

<!--more-->

All parts needed in this how-to can be bought for less than 2 Euro or 2 USD from China. I'm going to use the following items which were already available in my craft crate:

- [Digispark USB Development Board](http://digistump.com/category/1)
- Temperature sensor [TMP36](http://www.analog.com/media/en/technical-documentation/data-sheets/TMP35_36_37.pdf) (or any other sensor that gives you an analog signal)
- Cables (if you don't want to connect the sensor directly to the board)

The cabling is easy.

| Sensor | Digispark |
|--------|-----------|
| GND    | GND       |
| VCC    | 5V        |
| VOUT   | P4        |

There are other boards with the same size available. Like those with the far more powerful Mega32U4 chip. However, it would work with boards from the Arduino family as well if you adjust the code provided below.

The sketch is pretty simple. We are going to send the readings to a virtual [serial output](https://digistump.com/wiki/digispark/tutorials/digicdc) every 5 seconds. No logic needed. A little plus is that the onboard LED is blinking as an indicator that the board is working. [Upload](https://digistump.com/wiki/digispark) the code to your Digispark board. Keep in mind that the upload process is different than with Arduino or ESP8266 boards.

```cpp
#include <DigiCDC.h>

#define LED_PIN 1
#define INPUT_PIN 2  // Physical pin P4 is analog input 2

void setup() {
  SerialUSB.begin();
  pinMode(LED_PIN, OUTPUT);
}

void loop() {
  if (SerialUSB.available()) {
    digitalWrite(LED_PIN, HIGH);
    SerialUSB.delay(250);

    int reading = analogRead(INPUT_PIN);
    SerialUSB.println(reading);

    digitalWrite(LED_PIN, LOW);
    SerialUSB.delay(5000);
  }
}
```

To make it work with other boards simply use [`Serial.begin(115200);`](https://www.arduino.cc/en/Reference/Serial) and [`Serial.println(reading);`](https://www.arduino.cc/en/Serial/Println).

If you connect with a tool like `minicom` to your system's serial port `/dev/ttyACM0`, then you will get the data. To use the sensor with Home Assistant the [`serial`](/components/sensor.serial/) sensor platform needs to be set up. 

```yaml
sensor:
  - platform: serial
    port: /dev/ttyACM0
```

The physical sensor reads the current voltage of the pin. A [template sensor](/components/sensor.template/) takes the reading and converts it into a measurement. The data sheet of the sensor unit usually contains details about the involved calculations. 


```yaml
  - platform: template
    sensors:
      temperature:
        friendly_name: Temperature
        unit_of_measurement: "°C"
        value_template: "{{ (((states('sensor.serial_sensor') | float * 5 / 1024 ) - 0.5) * 100) | round(1) }}"
```


Hide the serial sensor if you don't want to see the raw data in the frontend and you are done. The whole setup with a Digispark is not very reliable because there is no hardware USB support. As a showcase and if you don't build your automation rules around it does the sensor what it should for a very small price. 


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effortless encryption with Let's Encrypt and DuckDNS]]></title>
    <link href="https://home-assistant.io/blog/2017/09/27/effortless-encryption-with-lets-encrypt-and-duckdns/"/>
    <updated>2017-09-27T00:05:00+00:00</updated>
    <id>https://home-assistant.io/blog/2017/09/27/effortless-encryption-with-lets-encrypt-and-duckdns</id>
    <content type="html"><![CDATA[When Let's Encrypt launched we were estatic: finally an easy and free way for our users to securely access their homes remotely. Let's Encrypt signifianctly lowered the bar to get and renew SSL certificates. However, this process could still be quite an obstacle for our users. It required opening ports on the router and remembering to renew the certificate every so often.

Thanks to a [blog post][splitbrain] by Andreas Gohr I realized that DuckDNS supports setting TXT records, making it compatible with the DNS-01 challenge of Let's Encrypt. The DNS-01 challenge is using the DNS record of the domain instead of interacting with the server. This means that it's not needed for the user to open any ports!

I have worked together with [Pascal Vizeli][pvizeli] on updating the DuckDNS add-on for Hass.io and today we're proud to announce it now includes automatic generation and updating of Let's Encrypt certificates for your DuckDNS domain. The only thing that you have to add to your DuckDNS configuration is that you accept the Let's Encrypt [terms of service][terms] and point Home Assistant at the generated certificates and you're good to go. No other work is required.

To get started today, start with making sure that you have [Hass.io installed][hassio]. After that, go to the Hass.io panel in Home Assistant, open the add-on store, scroll down to DuckDNS and install it. In the DuckDNS settings change "accept_terms" to true and start it.

Next up is to configure Home Assistant with the config below and restart it. You're now good to go! Make sure to use the right protocol when browsing to your instance: `https://<your_domain>.duckdns.org`. Happy secure controlling your house!

```yaml
# Example configuration.yaml entry for the HTTP component
http:
  ssl_certificate: /ssl/fullchain.pem
  ssl_key: /ssl/privkey.pem
```

If you're not using Hass.io, check out the [blog post][splitbrain] by Andreas for instructions.

If you enjoy the free service provided by DuckDNS and Let's Encrypt, consider donating to their cause:

 - [Become a Patreon of DuckDNS](https://www.patreon.com/user?u=3209735)
 - [Donate to Let's Encrypt](https://letsencrypt.org/donate/)

More information:

 - [Hass.io][hassio]
 - [Installing Hass.io][hassio-install]
 - [DuckDNS add-on][addon-duckdns]
 - [DuckDNS][duckdns]
 - [Let's Encrypt][le]

[splitbrain]: https://www.splitbrain.org/blog/2017-08/10-homeassistant_duckdns_letsencrypt
[terms]: https://letsencrypt.org/repository/
[pvizeli]: https://github.com/pvizeli
[hassio]: /hassio/
[hassio-install]: /hassio/installation/
[addon-duckdns]: /addons/duckdns/
[duckdns]: http://www.duckdns.org/
[le]: https://letsencrypt.org/
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Home Assistant on an Orange Pi Zero]]></title>
    <link href="https://home-assistant.io/blog/2017/05/13/home-assistant-on-orange-pi-zero/"/>
    <updated>2017-05-13T09:00:00+00:00</updated>
    <id>https://home-assistant.io/blog/2017/05/13/home-assistant-on-orange-pi-zero</id>
    <content type="html"><![CDATA[This blog post is about the setup of Home Assistant on an [Orange Pi Zero](http://www.orangepi.org/orangepizero/). Like the setup on a [Raspberry Pi Zero](/blog/2017/05/01/home-assistant-on-raspberry-pi-zero-in-30-minutes/) it will only take a couple of minutes to get a fully functional super cheap (less than 18 Euro incl. casing and power supply) Home Assistant hub. The reasons to use an Orange Pi Zero beside the prize are the built-in Ethernet port and the availability. 

<p class="img">
  <img src="/images/blog/2017-05-orangepi/orangie-pi-setup.png" />
</p>

<!--more-->

Download the [Armbian](https://www.armbian.com/orange-pi-zero/) and create the SD card with [Etcher](https://etcher.io/). There is no possibility to connect a display to the Orange Pi Zero. This means that you need a wired network setup with DHCP server. After your Orange Pi Zero is running, give it some time, and look for its IP address. The hostname is `orangepizero`.

If you found the IP address then use your SSH client to connect to the Orange Pi Zero. The default password is `1234`.

```bash
$ ssh root@192.168.0.151
[...]
root@192.168.0.151's password: 
You are required to change your password immediately (root enforced)
  ___                               ____  _   _____
 / _ \ _ __ __ _ _ __   __ _  ___  |  _ \(_) |__  /___ _ __ ___
| | | | '__/ _` | '_ \ / _` |/ _ \ | |_) | |   / // _ \ '__/ _ \ 
| |_| | | | (_| | | | | (_| |  __/ |  __/| |  / /|  __/ | | (_) |
 \___/|_|  \__,_|_| |_|\__, |\___| |_|   |_| /____\___|_|  \___/ 
                       |___/                                     

Welcome to ARMBIAN 5.27.170514 nightly Ubuntu 16.04.2 LTS 4.11.0-sun8i
System load:   0.86 0.35 0.13  	Up time:       9 min
Memory usage:  5 % of 496MB  	IP:            192.168.0.151
CPU temp:      39°C
Usage of /:    16% of 7.1G

[ General system configuration: armbian-config ]
New to Armbian? Check the documentation first: https://docs.armbian.com

Changing password for root.
(current) UNIX password: 
Enter new UNIX password: 
Retype new UNIX password: 

You are using Armbian nightly build.

It is provided AS IS with NO WARRANTY and NO END USER SUPPORT.

Creating a new user account. Press <Ctrl-C> to abort

Please provide a username (eg. your forename): ha
Trying to add user ha
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = "en_US.UTF-8",
	LC_ALL = (unset),
	LC_PAPER = "de_CH.UTF-8",
	LC_MONETARY = "de_CH.UTF-8",
	LC_NUMERIC = "de_CH.UTF-8",
	LC_MESSAGES = "en_US.UTF-8",
	LC_MEASUREMENT = "de_CH.UTF-8",
	LC_TIME = "de_CH.UTF-8",
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
Adding user `ha' ...
Adding new group `ha' (1000) ...
Adding new user `ha' (1000) with group `ha' ...
Creating home directory `/home/ha' ...
Copying files from `/etc/skel' ...
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
Changing the user information for ha
Enter the new value, or press ENTER for the default
	Full Name []: homeassistant
	Room Number []: 
	Work Phone []: 
	Home Phone []: 
	Other []: 
Is the information correct? [Y/n] y

Dear homeassistant, your account ha has been created and is sudo enabled.
Please use this account for your daily work from now on.

root@orangepizero:~# 
```
Get the latest details about the packages.

```bash
root@orangepizero:~# apt-get update
Hit:1 http://ports.ubuntu.com xenial InRelease
Get:2 http://ports.ubuntu.com xenial-security InRelease [102 kB]
Hit:3 http://beta.armbian.com xenial InRelease
Get:4 http://ports.ubuntu.com xenial-updates InRelease [102 kB]
Get:5 http://ports.ubuntu.com xenial-backports InRelease [102 kB]
Get:6 http://ports.ubuntu.com xenial-updates/main armhf Packages [479 kB]
Get:7 http://ports.ubuntu.com xenial-updates/universe armhf Packages [419 kB]
Fetched 1205 kB in 7s (158 kB/s)
Reading package lists... Done
```
Let's run an upgrade to make sure that all available packages are up-to-date.

```bash
root@orangepizero:~# apt-get upgrade
```
Now, we are installing the requirements for Home Assistant.

```bash
root@orangepizero:~# apt-get install python3-dev python3-pip python3-venv
```

Those steps to install Home Assistant are described in the [documentation](/docs/installation/armbian/) and the guide for [`venv`](/docs/installation/virtualenv/) as well. Switch to the create user `ha` and perform the remaining installation steps which are reduced to the minimum below:

```bash
ha@orangepizero:~$ pyvenv-3.5 homeassistant
ha@orangepizero:~$ cd homeassistant && source bin/activate
(homeassistant) ha@orangepizero:~/homeassistant$ pip3 install --upgrade pip
(homeassistant) ha@orangepizero:~/homeassistant$ pip3 install homeassistant
(homeassistant) ha@orangepizero:~/homeassistant$ hass
```

<p class="img">
  <img src="/images/blog/2017-05-orangepi/orange-pi-running.png" />
</p>

To make it ready for daily usage, don't forget to enable [autostart](/docs/autostart/).
]]></content>
  </entry>
  
</feed>
